\documentclass{article}
\usepackage{proof}
\usepackage{bussproofs}
\usepackage{xcolor}
\usepackage{url}
\usepackage{framed}
\usepackage{amsmath, amsfonts, amssymb}
\usepackage{mathtools}
\usepackage{minted}

\usepackage{hyperref}
\hypersetup{
 pdfborder={0 0 0},
 colorlinks=true,
 linkcolor=blue,
 urlcolor=blue,
 citecolor=blue
}
\usepackage{cleveref}


\newcommand{\rem}[1]{\textcolor{red}{[#1]}}
\newcommand{\ed}[1]{\textcolor{blue}{#1}}
\newcommand{\ct}[1]{\rem{#1 --ct}}

\begin{document}
\title{Comprehensive Exam Report 2 - Relating Higher Order and First-Order Logics}
\author{Arjun Viswanathan}
\date{}
\maketitle

\section{Introduction}
\label{sec:intro}
	In this report, we will discuss the 
	internals of two tools that use 
	automatic theorem provers (ATPs) to 
	provide automation to interactive 
	theorem provers (ITPs) - 
	SMTCoq~\cite{DBLP:phd/hal/Keller13} 
	and Sledgehammer's SMT solver 
	integration~\cite{bohme}. Specifically, 
	we will look at the following aspects 
	of each tool. For SMTCoq, we will study 
	how proof by reflection is used to 
	\textit{reflect} proofs from an SMT 
	solver to Coq's logic, and the data 
	structures used to facilitate this 
	reflection.	Sledgehammer provides a 
	translation of a fragment of 
	higher-order logic into first-order 
	logic, so that SMT-solvers can reason 
	about them. We will look into this 
	translation in detail.

\section{SMTCoq}
\label{sec:smtcoq}
	SMTCoq is a skeptical cooperation 
	between the Coq proof assistant, and 
	SAT and SMT solvers, implemented as a 
	Coq plugin. We will maintain a focus 
	on the SMT solver integration of 
	SMTCoq, noting that most features are 
	shared with the SAT	solver integration.
	
	ATPs like SMT solvers are susceptible 
	to bugs due to the large code-bases 
	used to support	their automaticity. 
	ITPs like Coq have a small trustable 
	proof kernel which would be 
	compromised if they were to trust
	external results. To avoid extending 
	Coq's trust-base, SMTCoq requires the 
	ATPs to be proof-producing, and uses 
	Coq's computational capabilities 
	to lift these up to Coq proofs, in a 
	process called computational 
	reflection. 
	
	\subsection{Proof by Reflection}
	\label{reflect}
	Coq's Calculus of Inductive 
	Constructions (CIC) is a 
	$\lambda-$calculus that has a 
	reduction mechanism for terms. The
	reduction rules form a strongly 
	normalizing system. The calculus's
	\textit{conversion rule} is an 
	important rule that allows different 
	terms to have the same types as 
	long as the types have the same 
	normal forms. For instance, for some 
	predicate $P$ over natural numbers, 
	a proof of $P(10)$ is also a proof 
	of $P(5*2)$, and of $P(20-10)$. Due 
	to the conversion rule, computations 
	can be used in Coq's reasoning and 
	proof terms can be found simply by 
	computing normal forms for types.
	
	A proposition in Coq is proved by 
	providing to Coq's type checker, a 
	proof term that inhabits the 
	proposition, or has the proposition 
	as its type. Automaticity can be 
	added to Coq by implementing 
	methods in Coq, that find the right 
	proof term for propositions --- a 
	process called \textit{proof search}. 
	Such a method could use an external 
	solver, such as an ATP, to guide 
	proof search. However, ATPs are 
	typically used to provide automatic 
	proofs without justification - 
	answering the question `is F 
	provable?' with	yes/no. To use the 
	result of an SMT solver without 
	compromising Coq's kernel the ATP 
	would have to produce, in addition 
	to a result, a \textit{proof trace} 
	that justifies the result. This 
	trace will guide the proof search 
	in Coq in a process called 
	\textit{proof reconstruction}. 
	Reconstruction can be implemented 
	as a meta-procedure. For example, 
	reconstruction of SMT solver proofs 
	in Isabelle/HOL are done external to 
	the prover's logic~\cite{bohme}. 
	This reconstruction can also be 
	expressed within the prover's logic 
	by a process called 
	\textit{computational reflection}, 
	which relies on the previously 
	mentioned reduction mechanism and 
	the conversion rule.

	SMT solvers prove propositions, or 
	formulas of type \texttt{Prop} in 
	Coq. To avoid compromising Coq's 
	kernel, the external solver doesn't 
	directly produce proofs for 
	\texttt{Prop}s.	Instead, formulas 
	in the SMT solver's	language are 
	represented in Coq using data 
	structures. This is called a 
	\textit{deep embedding} of SMT 
	formulas in Coq. Coq formulas, 
	represented using Coq types such 
	as \texttt{Prop} form a 
	\textit{shallow embedding} of 
	SMT formulas. Deep terms offer 
	better support for computations 
	over SMT terms. We can use Coq's 
	computational tools such as 
	induction and recursion to reason 
	about deep terms and 
	define properties over the them. 
	On the other hand, deep terms 
	are more complicated to specify, 
	since features such as binders 
	and variable substitutions must 
	be handled by writing functions 
	for these within Coq. These 
	features are available as part 
	of Coq's language for shallow 
	terms. 
	
	A proof produced by an 
	ATP in the deep embedding is 
	\textit{reflected} to a proof 
	of a Coq \texttt{Prop} (the shallow 
	embedding). This process requires 
	an \textit{interpretation function}
	which defines the meaning of 
	formulas in the deep embedding in 
	terms of those in the shallow 
	embedding. Additionally, the 
	\textit{reflection principle} is 
	a powerful lemma that relates all 
	formulas represented as data 
	structures in Coq, to formulas 
	represented as \texttt{Prop}s. The 
	proof involves an induction on the 
	structure of the data structures in 
	order to prove their similarity to 
	the shallow terms, while using the
	interpretation function. This 
	proof is factored once and can be 
	reused by instantiating  it with 
	specific formulas proved by the 
	external solvers. Work is then done 
	by Coq's computational mechanism to 
	check that the proof trace from the 
	SMT solver proves the formula it 
	claims to prove. Deep and shallow 
	embeddings were first introduced 
	while discussing embedding hardware 
	description languages in the HOL 
	theorem 
	prover~\cite{10.5555/645902.672777}.
	
	Formally, reflection of proofs 
	in SMTCoq is defined as follows. 
	In Coq, we have 
	\begin{itemize}
		\item \texttt{form} --- a data 
		structure representing the deep 
		embedding of SMT formulas
		\item \texttt{Prop} --- the type
		of propositions in Coq 
		representing the shallow 
		embedding of SMT formulas
		\item $\mathbb{I}$ --- the 
		interpretation function, which 
		is a predicate over \texttt{form}s 
		(of type \texttt{form} $\to$ 
		\texttt{Prop})
		\item \texttt{T} --- the type of 
		proof traces of $\mathbb{I} (f)$ 
		for some $f : \texttt{form}$
	\end{itemize}
	Reflection requires the following:
	\begin{itemize}
		\item a function 
		\texttt{check : form $\to$ T $\to$ 
		bool} implemented in Coq such that 
		\texttt{check}$\ f\ t$ is 
		\texttt{true} if trace $t$
		justifies $\mathbb{I}(f)$,
		where $f$ has type 
		\texttt{form}
		\item a lemma that proves the 
		correctness of \texttt{check}:
		\begin{center}
			\texttt{check\_correct :}
			$\forall\ (f : \texttt{form})\ 
			(t : \texttt{trace}),\ 
			\texttt{check}\ s\ t\ = 
			\texttt{true} \to \mathbb{I}(s)$
		\end{center}
		This is called the 
		\textit{reflection principle}.
	\end{itemize}
	The reflection principle relates 
	the computational behavior of 
	\texttt{check} to its propositional 
	meaning. For some $f : \texttt{form}$
	and trace $t$, the proof of 
	$\mathbb{I}(f)$ is:
	\begin{center}
		$\texttt{check\_correct}\ \ 
		f\ \ t\ \ (\texttt{refl\_equal}\ \ 
		(\texttt{check}\ f\ t)\ \ 
		\texttt{true})$
	\end{center}
	where \texttt{refl\_equal} is a tactic
	that forces the Coq type checker to 
	perform an equality check between 
	$\texttt{check}\ f\ t$ and \texttt{true}
	by reduction. The reflection principle 
	is proved once and is reused for 
	each formula. However, the trade-off is 
	that the reduction mechanism and the 
	conversion rule are invoked for each 
	application of the proof, adding a 
	computational overhead. 
	
	\subsection{Reflection in SMTCoq}
	In the following, we present SMTCoq's 
	deep embedding more concretely. 
	\texttt{form}, the type of formulas, 
	looks like this:
	\begin{minted}{coq}
Inductive form : Type :=
	| Fatom (_ : atom)
	| Ftrue
	| Ffalse
	| Fand (_ : array form)
	| For (_ : array form)
	| Fimp (_ : array form)
	| Fxor (_ _ : form)
	| Fiff (_ _ : form)
	| Fite (_ _ _ : form)
	| Fnot2 (_ : form)
	\end{minted}
	where a formula can be an atom, 
	\texttt{true}, \texttt{false};
	a conjunction, disjunction, or 
	implication of two or more 
	formulas; an exclusive-or or
	equivalence of two formulas; 
	an if-then-else of three formulas, 
	or a double negation of a formula.
	
	Formulas or their negations 
	represent literals:
	\begin{minted}{coq}
Inductive lit : Type :=
	| Pos (_ : form)
	| Neg (_ : form)
	\end{minted}
	and a clause is a list of literals,
	and a state is a set of clauses.
	The \texttt{form} type references 
	\texttt{atom}, the type of atoms, 
	which represents variables, 
	constants, functions and 
	applications of different theories.
	
	\noindent The \texttt{check} 
	function is implemented as the 
	\textit{main checker}: 
	\begin{center}
		\texttt{main\_checker ($input$ : 
			state) ($trace$ : t) : bool}	
	\end{center}
	
	The main checker splits up the 
	checking among a number of 
	\textit{small checkers}. The 
	trace is an array of \textit{steps}, 
	and each step can be independently 
	checked by a small checker. Currently, 
	there are small checkers for steps 
	that perform clause resolution, 
	conversion of formulas to conjunction 
	normal form (CNF), SMT solver 
	simplifications, and one for each 
	theory:	equality over uninterpreted 
	functions (EUF), linear integer 
	arithmetic (LIA), bit-vectors (BV), 
	and functional arrays with 
	extensionality (AX). The reflection 
	principle is a proof of correctness 
	of the main checker:
	\begin{align*}
		\texttt{main\_checker\_correct
		: } &\texttt{$\forall$ $input$ 
		$trace$, main\_checker $input$ 
		$trace$ = true}\\
		&\texttt{$\to$ $\forall$ 
		$\mathbb{I}$, $\neg$ 
		$\mathbb{I}$($input$)}
	\end{align*}
	where $\mathbb{I}$ is the 
	interpretation function that 
	relates the input to Coq's 
	\texttt{Prop} type. The negation of 
	the interpretation is checked because 
	of the duality between satisfiability 
	and validity: a formula is valid, if 
	and only if its negation is 
	unsatisfiable. The checker is 
	\textit{sound} : when it returns 
	\texttt{true} for a particular state, 
	the formulas in the state are 
	unsatisfiable, but not 
	\textit{complete}: when it returns 
	\texttt{false} we can't be certain 
	that the formulas in the state are 
	satisfiable. This is because the 
	SMT solver isn't decidable --- given 
	a set of formulas, it could either 
	return \texttt{sat} (satisfiable), 
	\texttt{unsat} (unsatisfiable), or 
	\texttt{unknown} (`don't know`).
	The proof of correctness of the main 
	checker is also composed of the 
	proofs of correctness of the small 
	checkers, and these proofs involve 
	inductions over the structures of 
	the different types presented 
	above. 
	
	There are some differences between
	the embedding presented above 
	and the actual deep embedding 
	of SMT terms in SMTCoq. The 
	latter uses Coq's machine 
	integers to implement sharing 
	of terms and optimize space, 
	but an unoptimized version is 
	presented above for brevity.

	
\section{Sledgehammer}
\label{sec:hammer}
	Isabelle~\cite{DBLP:journals/corr/cs-LO-9301106} 
	is an LCF-style system that 
	provides a meta-logic which can be 
	instantiated with other logics.
	Isabelle/HOL~\cite{10.5555/1791547}, 
	one of the most popular Isabelle 
	instantiations, implements a 
	classical higher-order logic. 
	
	Sledgehammer is
	an Isabelle/HOL component that 
	uses external ATPS to enhance 
	Isabelle/HOL with proof 
	automation. Initially, these 
	ATPs only included resolution 
	provers~\cite{10.1007/978-3-642-39799-8_1}.
	The work by Bohme et 
	al.~\cite{bohme} involved 
	extending Sledgehammer to 
	incorporate SMT
	solvers~\cite{Barrett2018} and this 
	work will be our focus for the 
	rest of this section. As with 
	SMTCoq, the SMT solvers integrated
	with Sledgehammer produce a 
	\textit{proof trace} which is 
	then \textit{reconstructed} within
	Isabelle/HOL by Sledgehammer, 
	using Sledgehammer's own internal 
	ATP --- Metis~\cite{hurd2003d}. The 
	proof trace essentially, guides 
	the inference steps of the proof 
	within Isabelle/HOL.
\bibliographystyle{abbrv}
\bibliography{bib2}

\end{document}