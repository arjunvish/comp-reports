\documentclass[11pt]{article}
\usepackage{proof}
\usepackage{bussproofs}
\usepackage{xcolor}
\usepackage{url}
\usepackage{framed}
\usepackage{amsmath, amsfonts, amssymb}
\usepackage{mathtools}
\usepackage{minted}
\usepackage{stmaryrd}
\usepackage{verbatim}
\usepackage{fullpage}
\newtheorem{example}{Example}[section]

\usepackage{hyperref}
\hypersetup{
 pdfborder={0 0 0},
 colorlinks=true,
 linkcolor=blue,
 urlcolor=blue,
 citecolor=blue
}
\usepackage{cleveref}


\newcommand{\rem}[1]{\textcolor{red}{[#1]}}
\newcommand{\ed}[1]{\textcolor{blue}{#1}}
\newcommand{\ct}[1]{\rem{#1 --ct}}

\begin{document}
\title{Comprehensive Exam Report 3 - Proof Generation}
\author{Arjun Viswanathan}
\date{}
\maketitle

\section{Introduction}
\label{sec:intro}
	SMTCoq~\cite{DBLP:phd/hal/Keller13} 
	is a skeptical cooperation 
	between the Coq proof assistant, and 
	(SAT and) SMT solvers~\cite{Barrett2018}, 
	implemented as a 
	Coq plugin. This integration is 
	useful for the ITP (Coq) since it 
	allows proof goals in Coq to be 
	automatically discharged by an 
	SMT solver. However, unlike 
	Coq's small, verifiable kernel,
	SMT solvers have tens of thousands 
	of lines of code and are more prone
	to bugs. Since an SMT solver's code 
	base is much harder to verify, 
	many SMT solvers produce proofs
	of their results in addition to 
	a claim of (un)satisfiability
	of a set of formulas. For satisfiable 
	formulas, a proof is simply a
	satisfying model which is easy 
	to specify and check (for 
	quantifier-free formulas). For 
	unsatisfiable formulas, however,
	SMT solvers need to show that 
	the input formulas are inconsistent.
	They do this by reducing the formulas 
	to a trivial unsatisfiable formula
	$\bot$, or the empty clause 
	$\bot$. A proof 
	producing SMT solver is integrated 
	with Coq by checking the proof 
	inside Coq for a particular 
	representation of SMT formulas in 
	Coq. The checker is proven correct,
	lifting up the formulas
	to Coq formulas over Booleans via a
	process called computational 
	reflection (described in Report 2).
	
	An added complication in this 
	integration of SMT solvers with 
	Coq is the incompatibility of 
	their logics. Propositions in 
	Coq have the 
	\texttt{Prop} type which 
	implements a constructive
	or intuitionistic logic. SMT
	solvers, on the other hand, 
	implement a classical logic. This
	incompatibility is overcome in 
	SMTCoq by using SMT solvers to 
	prove Boolean goals in 
	Coq (of type \texttt{Bool})
	that are classical, and additionally, 
	supporting a fragment of 
	propositions that don't violate 
	the laws of constructive logic.
	
	The first half of this report 
	discusses the proof production 
	systems of SMT solvers. The
	second half explores the difference
	between the logics of SMT solvers
	and Coq, and SMTCoq's efforts 
	to prove formulas in Coq that 
	SMT solvers can help with,
	while being logically consistent.

\section{Preliminaries}
\label{sec:prelims}
	Many-sorted first-order logic (MSFOL)
	extends first-order logic with 
	types (or sorts). We present the 
	syntax in this section and the 
	semantics are presented in
	\cite{Barrett2018}. Syntactically, 
	the components of MSFOL are sorts 
	$\sigma$, terms $t$, and 
	formulas $\phi$. Sorts are 
	atomic entities that 
	represent types. Function types 
	--- ($\sigma_1$, \ldots, $\sigma_n$) 
	$\to$ $\sigma$ ---
	and relation types 
	--- ($\sigma_1$, \ldots, $\sigma_m$)
	are defined over sorts, and 
	are types of functions and 
	predicates. Terms $t$ and 
	formulas $\phi$ are specified as:
	\begin{align*}
	t &:= x^{\sigma}\ |\ 
	f^{(\sigma_1, \ldots, \sigma_n) \to 
		\sigma}	(t_1, \ldots, t_n)\\
	\phi &:= \bot\ |\ \neg \phi\ |\ 
	\phi_1 \land \phi_2\ |\ \forall 
	x^{\sigma} . \phi\ |\ t_1 = t_2
	\ |\ P^{\sigma_1,\ldots,\sigma_m}
	(t_1, \ldots, t_m)
	\end{align*}
	Terms are either sorted variables, 
	or applications of sorted function
	symbols to terms.
	Formulas are constants or logical 
	connectives applied to other 
	formulas, quantified formulas, 
	equality over terms, or predicates
	symbols applied to terms. Connectives 
	$\top$, $\lor$, $\Rightarrow$, 
	$\Leftrightarrow$, and the 
	existential	quantifier $\exists$ 
	can be specified using the connectives 
	and quantifiers mentioned above.
	
	An \textit{atomic formula} is one 
	of $\bot$, $t_1 = t_2$, 
	$P^{\sigma_1,\ldots,\sigma_m}$ and a 
	\textit{literal} is an atomic 
	formula or it's negation. 
	A \textit{clause} is a 
	disjunction of literals. All formulas 
	can be converted to conjunction normal 
	form (CNF) which is a conjunction of 
	clauses. For ease of notation, 
	a formula in CNF is also represented
	as a set of clauses within curly 
	braces. $\bot$, the symbol
	representing false, 
	is overloaded to also represent
	the empty clause, which is trivially
	unsatisfiable (unlike the empty set,
	or the empty conjunction which is 
	trivially satisfiable).
	
	Informally, a formula is satisfiable
	if there exists a satisfying model 
	--- an assignment of well-sorted 
	values to its variables such that 
	the interpretation of the formula 
	is $\top$; it is unsatisfiable if 
	no such model exists; it is valid
	if, for all models its interpretation
	is $\top$. This interpretation 
	is recursively defined in 
	Barrett et al.~\cite{Barrett2018}.
	We use the notation
	$var \mapsto val$ to signify the 
	assigment of value $val$ to 
	variable $var$, and group 
	assignments in curly braces. 
	For example, 
	$a \mapsto \top$ assigns Boolean value 
	$\top$ to $a$. $\models$ stands for 
	logical entailment and $\models_T$ 
	stands for entailment in theory $T$. 
	A formula is entailed from nothing, 
	if it is valid. For example, 
	$a \land b \models a$,
	$x > 3 \models_{LIA} x > 0$, and 
	$\models_{LIA} x > 3 \Rightarrow 
	x > 0$ are all logically sound 
	entailments --- the first one 
	propositionally, and the
	last two in the theory of linear 
	integer arithmetic.
	
	Declarative rules of the form
	\begin{center}
		$\infer[\mathit{rule\_name}]{C}{P_1 & \ldots & P_n}$
	\end{center}
	specify that if the premises $P_1$ to 
	$P_n$ hold, then the conclusion $C$
	holds. The resolution rule,
	which is used heavily in DPLL(T) proofs,
	simplifies two 
	clauses to a new clause as follows:
	\begin{center}
		$\infer[\mathit{Res}]{\phi_1 \lor \cdots \lor 
			\phi_n \lor \psi_1 \lor \cdots \lor 
			\psi_m}{\phi_1 \lor \cdots \lor \phi_n 
			\lor \chi & \neg \chi \lor \psi_1 
			\lor \cdots \lor \psi_m}$ 
	\end{center}
	The following is an instance of the 
	resolution rule.
	\begin{center}
		$\infer{a \lor c}{a \lor \neg b 
			& b \lor c}$
	\end{center}
	Given that two clauses hold, 
	and a \textit{pivot}, which is a 
	literal that occurs with opposite 
	polarities in each clause ($b$ in 
	the above example), the resolution 
	rule concludes that 
	the combination of the two clauses 
	without either occurrence of the 
	pivot holds.
	

\section{DPLL(T) Proofs}
\label{sec:smtproofs}
	The typical SMT solver composes 
	a SAT solver with multiple theory
	solvers in an abstraction-refinement
	cycle, where the SAT engine 
	tries to find a satisfying 
	model of the propositional
	abstraction of a given set of 
	constraints, and the theory
	solvers find a refutation of 
	the refinement of the model, if 
	one exists.
	This cycle is guided by the 
	DPLL(T) algorithm, which is an
	extension of the 
	DPLL~\cite{Loveland2016}
	(Davis-Putnam-Logemann-Loveland) 
	algorithm that adds theory-level 
	reasoning.
	
	An SMT solver converts its input 
	constraints into conjunction 
	normal form (CNF), which is a 
	conjunction of clauses. The 
	DPLL(T) algorithm then tries 
	to find a satisfying assignment 
	for these clauses, and 
	otherwise, by exhaustion 
	concludes their unsatisfiability.
	The steps taken to conclude 
	the unsatisfiability can be 
	translated into a chain of 
	resolutions of the input clauses 
	to conclude the empty clause 
	$\bot$ from them, which is the 
	most basic form of unsatisfiability.
	
	A proof of unsatisfiability is a tree
	that derives, from the input formulas
	and \textit{theory lemmas} at the
	leaves, the empty clause $\bot$ at the root.
	The input formulas are converted to CNF
	via CNF conversion rules that are 
	part of the proof tree. We omit the 
	CNF conversion phase and start 
	with formulas that are already in 
	CNF. Thus, proof trees as shown in 
	this report have input clauses 
	and theory lemmas at the leaves, 
	and $\bot$ at the root, where 
	clauses are reduced in the tree 
	using the resolution rule. Theory 
	lemmas are the theory solvers' 
	means of refining the SAT solver's
	model for the input. A
	theory lemma, produced by the 
	corresponding theory
	solver, is a clause that is
	valid in a theory. The theory 
	solvers use theory-specific 
	rules to prove these 
	lemmas. A theory lemma in the 
	proof tree is supported by a 
	satellite proof of the lemma
	provided by the theory solver. 
	
	In what follows, we explain the 
	DPLL(T) algorithm and the 
	extraction of a resolution proof
	from an execution of it on an 
	unsatisfiable input.
	
	\subsection{The DPLL(T) Algorithm}
	\label{sec:dpllt}
	
	DPLL(T) is originally presented 
	in Nieuwenhuis et 
	al.~\cite{DBLP:journals/jacm/NieuwenhuisOT06}, 
	and reiterated in Katz et 
	al.~\cite{DBLP:conf/fmcad/KatzBTRH16} 
	as a transition system. We briefly present 
	the transition system here. Katz et al. also 
	present the proof-production system of the 
	CVC4~\cite{DBLP:conf/cav/BarrettCDHJKRT11} 
	SMT solver for quantifier-free logics,
	that we follow in this report. While 
	other SMT solvers'
	proofs might vary in specifics from 
	CVC4's, the general idea of a 
	resolution-based proof is still common 
	across solvers.
	
	As previously mentioned, the DPLL(T)
	algorithm can be understood as 
	trying to satisfy the input constraints
	at the propositional level, with 
	refinements of models from 
	theory solvers. Checking whether a
	formula is unsatisfiable at the 
	propositional level involves 
	incrementally assigning literals
	deterministically to satisfy clauses
	(propagation), and when that isn't an 
	option, by guessing an 
	assignment. When a guess goes 
	down a path that results in 
	unsatisfiability, the algorithm 
	backtracks and checks whether the 
	formula is still unsatisfiable 
	when the guess is flipped.
	
	We now formalize the DPLL(T) algorithm 
	as a state transition systems that 
	operates on a set of transition rules. 
	The state of the system is either 
	$fail$ or $\langle M, F, C \rangle$ 
	where $M$ is a sequence that 
	represents the current 
	\textit{context}, that is, 
	the current assignment of literals in 
	the formula; a literal in $M$ is 
	preceded by a $\bullet$ if the literal 
	was a decision, that is, it was 
	guessed. For some variable $x$, 
	the assignment $x \mapsto \top$ is added 
	to the context by appending $x$ to 
	$M$ and $x \mapsto \bot$ is added by 
	appending $\neg x$. $F$ is a set of 
	clauses representing the input formula 
	in CNF. $C$ represents the conflict 
	clause, the clause from $F$ that is 
	falsified by the current assignment ---
	it is either a singleton set with 
	the conflict clause, or the empty 
	set representing no conflict. 
	$\prec_M$ is an ordering 
	on the literals in $M$ ---
	$l_1, \ldots, l_n \prec_M l$ if 
	$l_1, \ldots, l_n$ occur before 
	$l$ in $M$. If $M = M_0 
	\bullet M_1 \bullet \ldots \bullet M_n$, 
	such that no $\bullet$ occurs in 
	the $M_i$'s, then each $M_i$ is a
	\textit{decision level}, $M^{[i]}$ 
	denotes $M_0 \bullet \ldots \bullet M_i$,
	and and \texttt{lev} is a function 
	that maps a literal in $M$ to its 
	decision level. $Lit_F$ represents the 
	set of literals occurring in $F$.
	
	The initial state of the system is 
	$\langle (), F, \emptyset \rangle$. 
	The final state is one of:
	\begin{itemize}
		\item $fail$, when $F$ is 
		unsatisfiable.
		\item $\langle M, F_0, \emptyset \rangle$ 
		where $F$ is satisfiable, $F_0$ is 
		a transformation of $F$ by the 
		algorithm that maintains its 
		(un)satisfiability,	and $M 
		\models F_0$.
	\end{itemize}
	
	The transition system goes from the 
	initial state to one of the possible 
	final states by a nondeterministic 
	application of the transition rules 
	presented in Figure~\ref{fig:proprules} 
	and Figure~\ref{fig:theoryrules}. In 
	practice, they are applied using a 
	particular strategy for efficiency.
	A rule is applicable when all its 
	premises hold, and it is applied to 
	make the conclusion true. 

	\begin{figure}[t]
	\centering
	\begin{framed}
	\begin{tabular}{c}
		$\infer[\mathit{Prop}]{M := Ml}{l_1 \lor \cdots \lor 
			l_n \lor l \in F & \neg l_1,\ldots,\neg 
			l_n \in M & l, \neg l \notin M}$ \\ \\
		$\infer[\mathit{Dec}]{M := M \bullet l}{l \in 
			Lit_F & l, \neg l \notin 
			M}$ \\ \\
		$\infer[\mathit{Confl}]{C:=\{l_1 \lor \cdots \lor 
			l_n\}}{C = \phi & l_1 \lor \ldots \lor 
			l_n \in F & \neg l_1,\ldots,\neg l_n \in 
			M}$ \\ \\
		$\infer[\mathit{Expl}]{C := \{l_1 \lor \cdots \lor 
			l_n \lor D\}}{C = \{\neg l \lor D\} & 
			l_1 \lor \cdots \lor l_n \lor l \in F & 
			\neg l_1,\ldots,\neg l_n \prec_M l}$ \\ \\
		$\infer[\mathit{Backj}]{C := \phi\ \ \ M := M^{[i]}l}
		{C = \{l_1 \lor \cdots \lor l_n \lor l\} & 
			\texttt{lev}\ \neg l_1, \ldots , 
			\texttt{lev}\ \neg l_n \leq 
			i < \texttt{lev}\ \neg l}$ \\ \\
		$\infer[\mathit{Learn}]{F := F \cup C}{C \neq 
			\phi}$ \\ \\
		$\infer[\mathit{Fail}]{fail}{C \neq \phi & \bullet 
			\notin M}$ \\ \\
	\end{tabular}
	\end{framed}
	\caption{Transition rules at Propositional level}
	\label{fig:proprules}
	\end{figure}

	\begin{figure}[t]
	\centering
	\begin{framed}
	\begin{tabular}{c}
		$\infer[\mathit{Prop_i}]{M := Ml}{l \in Lit_F 
			 & \models_i l_1 \lor 
			\cdots \lor l_n \lor l & \neg l_1, 
			\ldots, \neg l_n \in M & l,\neg l 
			\notin M}$ \\ \\
		$\infer[\mathit{Confl_i}]{C := \{l_1 \lor \cdots 
			\lor l_n \}}{C = \phi & \models_i 
			l_1 \lor \cdots \lor l_n & \neg l_1, 
			\ldots, \neg l_n \in M}$ \\ \\
		$\infer[\mathit{Expl_i}]{C := \{l_1 \lor \cdots 
			\lor l_n \lor D\}}{C = \{\neg l 
			\lor D\} & \models_i l_1 \lor \cdots
			\lor l_n \lor l & \neg\ l_1, \ldots, 
			\neg\ l_n \prec_M l}$ \\ \\
	\end{tabular}
	\end{framed}
	\caption{Transition rules at Theory level}
		\label{fig:theoryrules}
	\end{figure}

	The propositional rules from
	Figure~\ref{fig:proprules}
	model the behavior of the SAT solver.
	Propagations ($\mathit{Prop}$) force 
	assignments of Boolean values to literals 
	that are propositionally entailed. 
	For instance, if the input 
	formula is $\neg a \land (a \lor b)$, 
	then the assignment $a \mapsto \bot$ is 
	required to satisfy the first conjunct,
	$\neg a$. Now, $b \mapsto \top$ is the only 
	way to satisfy the second conjunct, 
	$(a \lor b)$. Both of these assignments 
	are logically entailed propagations, 
	given the goal of satisfying the formula. 
	Sometimes a deterministic choice 
	might not be entailed, instead, 
	an assignment must be guessed 
	using the decide rule ($\mathit{Dec}$). For 
	example, to 
	satisfy $(\neg a \lor b) \land 
	(\neg b \lor c) \land (\neg c \lor 
	\neg a)$, a formula 
	with no possible propagations, 
	one of the literals must be 
	non-deterministically assigned.
	For instance, the guess $a \mapsto \top$
	forces propagations $b \mapsto \top$ and 
	$c \mapsto \bot$. Propogations and/or 
	decisions could lead to a model in 
	which the input formula is not satisfied.
	The conflict rule ($\mathit{Confl}$) recognizes 
	this. In the previous example, the 
	decision $a \mapsto \top$ led via 
	propagations to the assignment
	$\{a \mapsto \top,\ b \mapsto \top,\ 
	c \mapsto \bot\}$, which falsifies 
	the second conjunct of the formula 
	and satisfies the others. The 
	$\mathit{Confl}$ rule recognizes this 
	clause ($\neg b \lor c$) to be the 
	conflict clause. Once a conflict is 
	encountered, where no previous 
	decisions were made, then the 
	conflict was entailed, and the 
	unsatisfiability of the input formula
	can be concluded via the $\mathit{Fail}$ rule. 
	If, there are previous decisions at
	the time of conflict, then the backjump
	rule ($\mathit{Backj}$) picks a decision that is 
	most likely the one that resulted in 
	the conflict, rewinds the state to 
	that decision and flips the decision. 
	To do this, it might need the explain 
	rule ($\mathit{Expl}$) to modify the 
	conflict clause using resolution. 
	Since the conflict clause is initially 
	a clause in the input, and it is only 
	modified by resolving it with other 
	input clauses, it is always entailed 
	by the input. At any point, a modified 
	conflict clause may be learned 
	($\mathit{Learn}$) by adding it to the 
	set of clauses in the input formula. 
	The restriction in the $\mathit{Backj}$ rule 
	that requires a literal in the 
	conflict clause to be at least 
	one decision level above the rest of 
	the clause, forces the transition 
	system to apply the $\mathit{Expl}$ rule 
	so that the algorithm is able to 
	backtrack further than chronological
	backtracking (where the most 
	recent decision is flipped), to 
	reach the source of the conflict.
	In our example, since there is only 
	one decision so far, the algorithm
	backjumps to the assignment of 
	$a$ and flips it to $a \mapsto \bot$. The 
	propagations $b \mapsto \top$ and $c \mapsto 
	\bot$ resulted from the assignment 
	$a \mapsto \top$, and these are undone
	by the backjump. After flipping our 
	initial decision, we have $a \mapsto 
	\bot$ which satisfies
	the first and third clauses of the 
	formula $(\neg a \lor b) \land 
	(\neg b \lor c) \land (\neg c 
	\lor \neg a)$. Since there 
	are no further propagations, the 
	decision $b \mapsto False$ can be made 
	to satisfy the second clause, and the 
	entire formula. 
	The theory-level rules
	from Figure~\ref{fig:theoryrules} model 
	the behavior of an abstract 
	theory solver. The $\mathit{Prop_i}$, 
	$\mathit{Confl_i}$, and $\mathit{Expl_i}$ rules
	work exactly like their 
	propositional variants, except 
	that they can use theory lemmas, 
	that are valid clauses in a 
	theory produced by the theory
	solver. Additionally, there is a
	$Learn_i$ theory-level rule that is 
	not presented here for simplicity. 
	
	The transition system is 
	\textit{refutationally sound}:
	if an execution starting with 
	$\langle \phi, F, \phi \rangle$ ends 
	with $fail$, then $F$ is 
	unsatisfiable in $T$. Under suitable 
	restrictions on the theory $T$ 
	involved, it is also 
	\textit{complete}: for every exhausted
	execution (an execution in which no 
	rule other than $\mathit{Learn_T}$ applies)
	starting with 
	$\langle \phi, F, \phi \rangle$,
	and ending with 
	$\langle M, F_0, \phi \rangle$,
	$M$ is a satisfying model of 
	$F_0$ (equisatisfiable with $F$)
	in $T$.	
	
	\begin{example}
	\label{ex:trans}
		\em Consider the following 
		CNF formula:
		\begin{center}
			$ F: \{f(g(z)) = h(y) \lor 
			x \neq y,\ \ f(g(z)) \neq 
			h(y) \lor x \neq y,\ \ 
			x = y \lor f(m) = f(n),\ \ 
			f(m) = x,\ \ f(n) = y\}$
		\end{center}
		Each term contains additional 
		information in the theory 
		of equality over uninterpreted 
		functions (EUF) where the only 
		predicate is equality, and all
		functions are uninterpreted. 
		However, this additional 
		information isn't available to 
		the SAT solver at the 
		propositional level. We consider 
		the following abstraction 
		of the theory literals in $F$, 
		for simplicity of representation. 
		\begin{center}
			$\ F: \{A \lor \neg B,\ 
			\neg A \lor 
			\neg B,\ B \lor C,\ D,\ 
			E\}$
		\end{center}
		$A$ abstracts $f(g(z)) = h(y)$,
		$\neg A$ abstracts, $f(g(z))
		\neq h(y)$,
		and so on.
	
		An execution of the DPLL(T) 
		algorithm from the previous 
		section on $F$, from 
		initial to final state is 
		presented in 
		Figure~\ref{fig:dplltex}.
		\begin{figure}[t]
			\begin{center}
				\begin{tabular}{|l|l|l|l|l|}
					\hline
					\textbf{M} & \textbf{F} & \textbf{C} 
					& \textbf{Rule} & \textbf{Step}\\
					\hline
					& $A \lor \neg B,\, \neg A \lor 
					\neg B,\, B \lor C,\, D,\, E$ 
					& & $\mathit{Prop}\ (D)$ & 1\\
					$D$ & $A \lor \neg B,\, \neg A \lor 
					\neg B,\, B \lor C,\, D,\, E$ & 
					& $\mathit{Prop}\ (E)$ & 2\\
					$DE$ & $A \lor \neg B,\, \neg A \lor 
					\neg B,\, B \lor C,\, D,\, E$ & 
					& $\mathit{Dec}\ (A)$ & 3\\
					$DE\bullet A$ & $A \lor \neg B,\, 
					\neg A \lor \neg B,\, B \lor C,
					D,\, E$ & & $\mathit{Prop}\ (\neg A 
					\lor \neg B$) & 4\\
					$DE\bullet A \neg B$ & $A \lor 
					\neg B,\, \neg A \lor \neg B,\, 
					B \lor C,\, D,\, E$ & & 
					$\mathit{Prop}\ (B \lor C)$ & 5\\
					$DE\bullet A \neg B\ C$ & $A \lor 
					\neg B,\, \neg A \lor \neg B,\, B 
					\lor C,	D,\, E$ & & 
					$\mathit{Confl_{EUF}}\ (\neg C \lor$ 
					& 6\\
					&&&$\neg D \lor \neg E \lor B)$ &\\
					$DE\bullet A \neg B\ C$ & $A \lor 
					\neg B,\, \neg A \lor \neg B,\, B 
					\lor C,	D,\, E$ & $\neg C \lor
					\neg D \lor \neg E \lor	B$ & 
					$\mathit{Expl}\ (D)$ & 7\\
					$DE\bullet A \neg B\ C$ & $A \lor 
					\neg B,\, \neg A \lor \neg B,\, B 
					\lor C,	D,\, E$ & $\neg C \lor
					\neg E \lor	B$ & $\mathit{Expl}\ (E)$ & 
					8\\
					$DE\bullet A \neg B\ C$ & $A \lor 
					\neg B,\, \neg A \lor \neg B,\, B 
					\lor C,\, D,\, E$ & $\neg C \lor B$ 
					& $\mathit{Expl}\ (B \lor C)$ & 9\\
					$DE\bullet A \neg B\ C$ & $A \lor 
					\neg B,\, \neg A \lor \neg B,\, B 
					\lor C,	D,\, E$ & $B$ & $\mathit{Expl}\  
					(\neg A \lor \neg B)$ & 10\\
					$DE\bullet A \neg B\ C$ & $A \lor 
					\neg B,\, \neg A \lor \neg B,\, B 
					\lor C,\, D,\, E$ & $\neg A$ & 
					$\mathit{Learn}\ (\neg A)$ & 11\\
					$DE\bullet A \neg B\ C$ & $A \lor 
					\neg B,\, \neg A \lor \neg B,\, B 
					\lor C,\, D,\, E,\, \neg A$ & $\neg 
					A$ & $\mathit{Backj}\ (\neg A)$ & 12\\
					$DE\neg A$ & $A \lor \neg B,\, \neg 
					A \lor \neg B,\, B \lor C,\, D,\, E,\, 
					\neg A$ & & $\mathit{Prop}\ (A 
					\lor \neg B)$ & 13\\
					$DE\neg A \neg B$ & $A \lor \neg B,\, 
					\neg A \lor \neg B,\, B \lor C,
					D,\, E,\, \neg A$ & & $\mathit{Prop}\  
					(B \lor C)$ & 14\\
					$DE\neg A \neg B\ C$ & $A \lor \neg 
					B,\, \neg A \lor \neg B,\, B \lor C,\, 
					D,\, E,\, \neg A$ & & 
					$\mathit{Confl_{EUF}}\ (\neg C \lor$
					& 15\\
					&&&$\neg D \lor \neg E \lor B)$ &\\
					$DE\neg A \neg B\ C$ & $A \lor 
					\neg B,\, \neg A \lor \neg B,\, B 
					\lor C,	D,\, E,\, \neg A$ & $\neg C 
					\lor \neg D \lor \neg E \lor	
					B$ & $\mathit{Expl}\ (D)$ & 16\\
					$DE\neg A \neg B\ C$ & $A \lor 
					\neg B,\, \neg A \lor \neg B,\, B 
					\lor C,	D,\, E,\, \neg A$ & $\neg C \lor
					\neg E \lor	B$ & $\mathit{Expl}\  
					(E)$ & 17\\
					$DE\neg A \neg B\ C$ & $A \lor \neg 
					B,\, \neg A \lor \neg B,\, B \lor C,\, 
					D,\, E,\, \neg A$ & $\neg C \lor B$ 
					& $\mathit{Expl}\ (B \lor C)$ & 18\\
					$DE\neg A \neg B\ C$ & $A \lor \neg 
					B,\, \neg A \lor \neg B,\, B \lor C,\, 
					D,\, E,\, \neg A$ & $B$ & $\mathit{Expl}\ (A 
					\lor \neg B)$ & 19\\
					$DE\neg A \neg B\ C$ & $A \lor \neg 
					B,\, \neg A \lor \neg B,\, B \lor C,\, 
					D,\, E,\, \neg A$ & $A$ & $\mathit{Expl}\  
					(\neg A)$ & 20\\
					$DE\neg A \neg B\ C$ & $A \lor \neg 
					B,\, \neg A \lor \neg B,\, B \lor C,\, 
					D,\, E,\, \neg A$ & $\bot$ & $\mathit{Fail}$ & 
					21\\
					\hline
				\end{tabular}
			\end{center}
			
			\caption{Execution of the DPLL(T) algorithm on $F$}
			\label{fig:dplltex}
		\end{figure}
		The first and only decision is made in 
		step 3 when $A \mapsto \top$ is assigned.
		In step 6, the current assignment is 
		found to be conflicting with theory
		lemma $\neg C \lor \neg D \lor \neg E
		\lor B$, but since this conflict 
		came in a context where a decision
		was made, the decision is reversed
		in step 12, after the conflict clause 
		is simplified and learned. In step 15, 
		when the same lemma is found to be 
		conflicting with the new context, we 
		can conclude that the input is 
		unsatisfiable using the $\mathit{Fail}$ rule, 
		since we tried both choices of 
		assignment for $A$. This is what 
		the solver would typically do. However, 
		the empty clause $\bot$ 
		is trivially unsatisfiable and in 
		some given context where 
		$x \mapsto \top$ for some $x$, an 
		acceptable proof of unsatisfiability 
		is to to derive from the context that 
		$x \mapsto \bot$ holds. Such a state 
		where some $x$ and $\neg x$ holds
		logically reduces to $\bot$ 
		($x$ and $\neg x$ resolve to $\bot$).
		Thus, given a set of formulas,
		a more uniform proof of 
		unsatisfiability of the set is 
		to derive $\bot$ from it. This is why, 
		in proof mode, the SMT solver, only 
		applies the final $\mathit{Fail}$ rule after 
		reducing the conflict clause to $\bot$
		using explanations. This is done 
		from step 15 to 21.\hfill$\Box$
	\end{example}
	
	\subsection{DPLL(T) Proofs}
	\label{sec:proofex}
	TODO pass and change pronouns. TODO talk about proof by contradiction.
	
	Given an execution of the DPLL(T)
	algorithm that ends in the $fail$ state, 
	the solver proves that the input formula 
	$F$ is unsatisfiable by building a 
	\textit{refutation tree} of $F$ --- a 
	tree with the input clauses 
	and theory lemmas at the leaves, 
	that lead, through the application of 
	the resolution rule, to the empty 
	clause $\bot$ at the root. A
	resolution proof can be extracted 
	from a DPLL(T) execution
	by following the applications of 
	the $\mathit{Confl}$ and 
	$\mathit{Expl}$ rules. Notice, that
	the $\mathit{Expl}$ rule 
	modifies the current conflict clause by 
	resolving it with an input clause, and 
	it is precisely these resolutions 
	that guide the creation of the proof tree.
	
	\begin{example}
	\label{ex:propproof}
		\em Figure~\ref{fig:propproof} shows 
		the proof tree of the 
		unsatisfiability of $F$ from 
		Example~\ref{ex:trans}. 
		The nodes of the tree contain the 
		clause being used. Every reduction 
		of (a pair of) nodes to a child node 
		is an application of the resolution 
		rule. The label 
		of the resolution of two 
		nodes in the tree shows the 
		step number of the application 
		of the $\mathit{Expl}$ from 
		Figure~\ref{fig:dplltex}.
		The left subtree is a proof of 
		$\neg A$, which is learned in steps 
		1 to 11, and the right subtree is the 
		proof of $A$ which is concluded from 
		steps 12 to 20. Step 21 performs 
		the final resolution of $A$ and 
		$\neg A$ to derive $\bot$.
		\begin{figure}[t]
			Refutation tree of $F$:
			\begin{prooftree}
				\defaultHypSeparation {\hskip 0in}
				\AxiomC{Proof of $\neg A$}
				\AxiomC{Proof of $A$}
				\RightLabel{20}
				\BinaryInfC{$\bot$}
			\end{prooftree}
			where Proof of $\neg A$:
			\begin{prooftree}
				\AxiomC{$\mathcal{P}$}
				\UnaryInfC{$\neg C \lor \neg D 
					\lor \neg E \lor B$}
				\AxiomC{$D$}
				\RightLabel{7}
				\BinaryInfC{$\neg C \lor \neg E 
					\lor B$}
				\AxiomC{$E$}
				\RightLabel{8}
				\BinaryInfC{$\neg C \lor B$}
				\AxiomC{$B \lor C$}
				\RightLabel{9}
				\BinaryInfC{$B$}
				\AxiomC{$\neg A \lor \neg B$}
				\RightLabel{10}
				\BinaryInfC{$\neg A$}
			\end{prooftree}
			and Proof of $A$:
			\begin{prooftree}
				\AxiomC{$\mathcal{P}$}
				\UnaryInfC{$\neg C \lor \neg D 
					\lor \neg E \lor B$}
				\AxiomC{$D$}
				\RightLabel{16}
				\BinaryInfC{$\neg C \lor \neg E 
					\lor B$}
				\AxiomC{$E$}
				\RightLabel{17}
				\BinaryInfC{$\neg C \lor B$}
				\AxiomC{$B \lor C$}
				\RightLabel{18}
				\BinaryInfC{$B$}
				\AxiomC{$A \lor \neg B$}
				\RightLabel{19}
				\BinaryInfC{$A$}
			\end{prooftree}
			\caption{Proof tree for example in 
				Figure~\ref{fig:dplltex}. $\mathcal{P}$
				is the proof of the theory lemma
				from the theory solver.}
			\label{fig:propproof}
		\end{figure}
	$\mathcal{P}$ is the proof of the 
	theory lemma that is expanded in 
	the next subsection.\hfill$\Box$
	\end{example}

	Finally, the theory lemmas used
	in the proof appear at the leaf
	of the tree, and need to be justified 
	by proofs of the lemmas from 
	the theory solver. This is explained in 
	the next subsection.
	
	\subsection{Theory Lemma Proofs}
	\label{sec:thproof}
	Theory lemmas at the leaves are 
	justified by satellite proofs 
	from the theory solver that produce 
	them. They prove the lemma 
	by contradiction --- they derive
	the formula $\bot$ from the 
	negation of clause $C$, and the 
	$\mathit{Lemma}$ rule derives $C$
	from this. A negation of a clause
	is a conjunction of each of the 
	clause's disjuncts, 
	separately negated. The proof 
	consists of a box, from which the 
	lemma is concluded. Within the box
	is a proof tree with these negated 
	disjuncts at the leaves, and $\bot$
	at the root. 
	
	\begin{example}
		\em The only theory lemma
		used in our example is 
		\begin{align*}
		L :\ & \neg C \lor \neg D \lor 
		\neg E \lor B \\
		\textrm{or, }L :\ & f(m) \neq f(n) 
		\lor f(m) \neq x \lor 
		f(n) \neq y \lor x = y\\
		\textrm{equivalently, }L :\ &
		f(m) = f(n) \Rightarrow 
		f(m) = x \Rightarrow f(n) = y 
		\Rightarrow x = y
		\end{align*}
		Taking its negation gives:
		\begin{align*}
		\neg L :\ & C \land D \land E \land \neg B\\
		\textrm{or, } \neg L :\ & 
		f(m) = f(n) \land f(m) = x \land
		f(n) = y \land x \neq y
		\end{align*}
		Finally, the proof tree from the 
		theory solver of $L$, or $\mathcal{P}$ from 
		Figure~\ref{fig:propproof} is 
		shown in Figure~\ref{fig:eufproof}. It derives
		$\bot$ at the root of a tree that contains the 
		conjuncts of $\neg L$ as leaves --- $C, D, E, 
		\neg B$. It applies the $\mathit{Lemma}$ to 
		this box to derive $L$. The application 
		of the $\mathit{Lemma}$ rule is the 
		unlabeled rule application from 
		$\mathcal{P}$ to $L$ in Figure~\ref{fig:propproof},
		so $\mathcal{P}$ is technically the 
		proof tree in the box. The proof
		uses the transitivity and symmetry of 
		equality in addition to the rule that 
		specifies the contradiction 
		between an equality and its negation.\hfill$\Box$
		\newcommand*\ruleline[1]{\noindent\raisebox{.8ex}{\makebox[\linewidth]{\hrulefill\hspace{1ex}\raisebox{-.8ex}{#1}}}}
		\renewenvironment{framed}[1][\hsize]
		{\MakeFramed{\hsize#1\advance\hsize-\width \FrameRestore}}
		{\endMakeFramed}
		\begin{figure}[t]
			\begin{framed}[.85\textwidth]
				\begin{prooftree}
					\AxiomC{$f(m) = x$}
					\RightLabel{$\mathit{Symm}$}
					\UnaryInfC{$x = f(m)$}
					\AxiomC{$f(m) = f(n)$}
					\RightLabel{$\mathit{Trans}$}
					\BinaryInfC{$x = f(n)$}
					\AxiomC{$f(n) = y$}
					\RightLabel{$\mathit{Trans}$}
					\BinaryInfC{$x = y$}
					\AxiomC{$x \neq y$}
					\RightLabel{$\mathit{Contra}$}
					\BinaryInfC{$\bot$}
				\end{prooftree}
			\end{framed}
			\vspace{-0.2in}\hspace{+0.25in}
			\ruleline{$\mathit{Lemma}$}
			\vspace{-0.35in}
			\begin{center}
				$f(m) \neq f(n) 
				\lor f(m) \neq x \lor 
				f(n) \neq y \lor x = y$
			\end{center}
			\caption{EUF Proof from Figure~\ref{fig:propproof}}
			\label{fig:eufproof}
		\end{figure}
	\end{example}


	\section{Classical vs Constructive Logic in Coq}
	\label{sec:logic}
	Coq is a proof assistant based on the 
	Calculus of Inductive Constructions 
	(CIC)~\cite{paulinmohring:hal-01094195},
	which is as an extension of the dependent 
	type theory --- the Calculus of Constructions 
	(CoC)~\cite{10.1016/0890-5401(88)90005-3} 
	--- with inductive types. Coq's type 
	systems implements an infinite hierarchy
	of types, where all objects, including 
	types, are terms that have types. 
	``Higher-order" types (types of types) are 
	distinguished from ``first-order" types 
	(types of terms that are not types), 
	by referring to 
	them as \textit{sorts}. At the bottom of the 
	type hierarchy, Coq has (1) regular first-order
	types such as \texttt{Bool} representing 
	Booleans and \texttt{Nat} representing 
	natural numbers, that are defined inductively
	and are themselves instances of the 
	\texttt{Set} sort, and (2) propositions or 
	properties in Coq that have sort 
	\texttt{Prop}. The rest of the 
	hierarchy looks like this: 
	\texttt{Prop} and 
	\texttt{Set} have sort 
	\texttt{Type$_1$} and 
	\texttt{Type$_i$} has sort 
	\texttt{Type$_{i+1}$}. The implementation 
	of propositions as a sort in Coq is its
	means of enforcing the Curry-Howard 
	correspondence between proofs and 
	terms (or programs), and between 
	propositions and types. The \texttt{Prop} 
	sort implements a constructive logic in 
	Coq. Constructive or intuitionistic logic 
	is a branch of mathematical logic 
	studying arguments concerning 
	constructive objects. A proposition 
	is provable in constructive logic, if 
	a (proof) term inhabiting the 
	proposition can be constructed.
	Thus, a \texttt{Prop} $P$ can be proved 
	in Coq only if a proof term having 
	type $P$ can be constructed. 	
	This term is constructed within 
	a \textit{proof script} in the Coq
	user-interface. Given a lemma, Coq 
	provides a \textit{goal} and 
	a \textit{proof context}, which 
	contains the 
	terms available to prove the goal.
	Initially, the goal is the entire 
	proposition being proven, and the 
	context is empty, and the user
	can manipulate the goal to break 
	it down and move over its 
	constituents into the context
	using Coq functions called 
	\textit{tactics}.
	
	\begin{example}
		\em The following Coq
		code proves the formula
		$a \Rightarrow a \lor b$, for any 
		\texttt{Prop}s $a$ and $b$. 		
	\begin{minted}{Coq}
Theorem orIntroL : forall (a b: Prop), a -> a \/ b.
Proof.
  intros a b Ha.
  left. apply Ha.
Qed.
	\end{minted}
		The formula asserts that given a 
		proof of the proposition $a$, we
		have a proof of the 
		disjunction of $a$ and $b$. The 
		universal quantifier 
		(\texttt{forall}) is a binder 
		that introduces arbitrary
		propositions \texttt{a} and 
		\texttt{b} into the lemma.
		The proof script between 
		\texttt{Proof} 
		and \texttt{Qed} constructs a 
		proof term of type \texttt{forall 
		(a b: Prop), a -> a $\backslash/$ b}. 
		The first line of the 
		script introduces 
		the propositions $a$ and $b$ and the 
		proof $Ha$ of $a$ into the 
		proof context (using the \texttt{intros}
		tactic). The only way to prove a 
		disjunction is to prove one 
		of the disjuncts. This is a crucial
		detail that distinguishes constructive
		logic from classical logic, as we 
		will see later in the section. 
		The second line of the proof script 
		proves the left disjunct by using 
		the proof of $a$ from the context.
		\hfill$\Box$
	\end{example}
	Classical logic extends 
	constructive logic with the 
	\textit{law of the excluded 
	middle} that states that for 
	arbitrary proposition $a$, 
	$a \lor \neg a$ holds. This can 
	also be stated as the 
	double negation elimination 
	law or as proving a 
	proposition by contradiction. As
	such, some statements that are true 
	in classical logic might not have 
	a proof in constructive logic.
	The law of the excluded middle
	itself is a convenient example.
	\texttt{forall (a : Prop), a $\lor$ ~a}
	is not provable in Coq, because,
	as mentioned before, the only way to 
	prove a propositional disjunction 
	is to prove that one of the disjuncts 
	holds and unlike \texttt{orIntroL},
	there is no way to prove either 
	of the disjuncts here.
	
	An SMT solver can prove classical 
	formulas that include both 
	$a \Rightarrow a \lor b$ and 
	$a \lor \neg a$ for arbitrary 
	Booleans $a$ and $b$. As
	such, \texttt{Prop} is not an 
	ideal candidate to embed SMT 
	formulas into, since with such 
	an embedding, SMT solvers would 
	be able to prove propositions 
	in Coq that are incompatible with
	Coq's constructive logic. In addition 
	to the \texttt{Prop} 
	type, Coq has a Boolean 
	(\texttt{bool}) type in its standard 
	library~\cite{CoqBool}, that defines 
	Booleans as an 
	inductive type with two nullary
	constructors \texttt{true} and
	\texttt{false}. This Boolean type 
	in Coq effectively implements a 
	classical logic. Any Boolean value can 
	be inspected, pattern matched on,
	and evaluated to either 
	\texttt{true} or \texttt{false}.
	Terms of type \texttt{bool} 
	cannot, by themselves, be 
	stated as theorems
	in Coq, since they don't have 
	the \texttt{Prop} type
	(they are not propositions). 
	To state that a Boolean term 
	$B$ holds for arbitrary values 
	of its variables, the term is 
	equated to \texttt{true}
	and its variables are 
	universally quantified.
	\begin{center}
		$F:\ Q,\ B = \texttt{true}$
	\end{center} 
	where $Q$ represents the 
	universal quantification of 
	the variables in $B$. Since 
	equality is a proposition, 
	and quantified propositions 
	are themselves propositions, 
	$F$ represents an embedding 
	of a Boolean term into a 
	proposition, which can now be
	used as a Coq goal. We 
	call such goals that 
	embed a Boolean term into a 
	proposition, \textit{Boolean
	goals}.
	\begin{example}
		\em The law of 
		excluded middle is 
		stated in Coq as a Boolean
		goal and proved
		as follows.
		\begin{minted}{coq}
Theorem LEMBool : forall a : bool, a || (negb a) = true.
Proof.
  intros a. destruct a.
  + simpl. reflexivity.
  + simpl. reflexivity.
Qed.
		\end{minted}
		\texttt{orb} is the 
		disjunction operator over 
		Booleans and has 
		infix notation \texttt{||},
		and \texttt{negb} is the 
		negation operator over 
		Booleans.
		\texttt{destruct a} performs a 
		case analysis on $a$, and since $a$ 
		is a Boolean that can 
		only be either \texttt{true}
		or \texttt{false}, the two lines
		beginning with \texttt{+} 
		replace the $a$ in the context
		with exactly those values.
		When $a$ is \texttt{true}, the 
		goal reduces to 
		\texttt{true || not true = true}
		and when it is \texttt{false}, it
		reduces to 
		\texttt{false || not false = true}.
		Both of these are simplified to 
		\texttt{true = true} using the 
		tactic \texttt{simpl} and then 
		by the reflexivity of 
		\texttt{true}, both equalities
		are provable. Notice that, 
		neither a proof of $a$, nor 
		a proof of $\neg a$ was 
		constructed here. Arguments were
		made in terms of every possible 
		value $a$ could take, and the
		conjecture was proven in 
		each case. Such a proof, as we 
		saw above, is impossible in 
		constructive logic.
		\hfill$\Box$
	\end{example}

	\subsection{The Role of SMTCoq}
	SMTCoq is a plugin that adds automation
	to Coq by dispatching goals to SMT
	solvers. Since SMT solvers implement 
	a classical logic, SMTCoq 
	uses SMT solver proofs to 
	prove classical formulas 
	expressed in Coq as Booleans
	goals. 
	
	\begin{example}
		\em The \texttt{LEMBool} lemma from 
		above would be a simple goal that 
		could be dispatched to an SMT 
		solver using SMTCoq's \texttt{smt}
		tactic:
		\begin{minted}{coq}
Theorem LEMBool' : forall a : bool, a || (negb a) = true.
Proof.
  smt.
Qed.
		\end{minted}
		\hfill$\Box$
	\end{example}
	SMTCoq embeds SMT formulas in 
	Coq as Boolean goals in what is 
	called a \textit{shallow embedding}, 
	which uses 
	types in Coq that correspond to SMT
	formulas, to embed SMT formulas
	in Coq. As such, SMT formula semantics 
	are already defined in Coq. A proof of a
	formula from an SMT solver is 
	translated to the proof of a Boolean
	goal in Coq via a \textit{deep embedding}.
	SMTCoq defines 
	\begin{itemize}
		\item the deep embedding of
			SMT formulas in Coq as the 
			\texttt{form} type, 
		\item an interpretation of 
			\texttt{form}s with respect to 
			\texttt{Bool}s,
		\item a checker for proofs of 
			(unsatisfiability of the 
			negation) the deep embedding 
			of formulas coming from the SMT 
			solver, and,
		\item a proof of correctness of 
			the checker, also called 
			the \textit{reflection lemma},
			that \textit{reflects} a proof
			of the deep embedding of a 
			formula from the SMT solver
			(successfully checked by the 
			checker) to the proof of a 
			Boolean goal in Coq (the 
			shallow embedding of 
			formulas).
	\end{itemize}
	This process is described in further
	detail in Report 2. 
	Figure~\ref{fig:prop2bool} and
	Figure~\ref{fig:smtcoqex} reproduce
	parts of the figure from 
	Report 2 illustrating this process, 
	although they do it in the context 
	of explaining SMTCoq's 
	\texttt{Prop} to \texttt{Bool}
	conversion, which is discussed in the
	next subsection.
	
	\subsection{Theories and Prop Predicates}
	SMTCoq integrates both 
	SAT and SMT solvers with Coq. If 
	it were reasoning about purely 
	Boolean goals such as 
	\texttt{LEMBool} above, it wouldn't 
	need SMT solvers at all. It could
	do that with just SAT, or
	propositional satisfiability,
	solvers. SMT, or satisfiability
	modulo theories, solvers provide 
	the ability to reason in theories
	such as finite- and infinite-precision 
	integers and arrays. Using its SMT 
	solver integration, SMTCoq is able to 
	prove more expressive Boolean goals
	over the theories of uninterpreted 
	functions, linear integer arithmetic,
	arrays, and bit-vectors. Recall that
	atomic formulas are applications of  
	predicate symbols to
	terms. Earlier in the section, 
	we looked at logical connectives 
	being represented classically (as 
	connectives over the \texttt{Bool}
	type) or constructively (as 
	\texttt{Prop} connectives). 
	
	Similarly, in this section, we will 
	refer to predicate symbols that 
	construct \texttt{Prop}s as
	\texttt{Prop} predicate symbols, and 
	those that construct \texttt{Bool}s 
	as \texttt{Bool} (or Boolean) predicate
	symbols, in Coq. A \texttt{Prop} predicate
	is a proposition in Coq, 
	parameterized
	by values (of any type, but we will 
	focus on the types in the theories 
	supported by SMTCoq.). A \texttt{Bool}
	predicate is a Boolean term,
	parameterized by values. To
	state that a \texttt{Bool} term
	holds, it's free variables must be 
	quantified and the term equated to 
	\texttt{true}, as demonstrated 
	in the previous section for connectives.
	
	\begin{example}
		\label{ex:boolpred}
		\em Consider the following examples
		of \texttt{Bool} predicates 
		over integers and bit-vectors.
		\begin{minted}{Coq}
Theorem Z_congBool : forall (a b : Z) (f : Z -> Z), 
  implb (Z.eqb a b) (Z.eqb (f a) (f b)) = true.
Proof.
  smt.
Qed.

Theorem BV_ulteZeroBool : forall (b : bitvector 4),
  (bv_ult #b|0|0|0|0| b) || (bv_eq b #b|0|0|0|0|) = true.
Proof.
  smt.
Qed.

		\end{minted}
		\texttt{Z\_congBool} proves the 
		congruence rule over integer 
		to integer functions and 
		\texttt{BV\_ulteZeroBool} proves 
		that all 4-bit integers (bit-vectors 
		of length 4) in their 
		unsigned interpretation are 
		greater than or equal to $0$. The
		operator
		\texttt{implb} is the implication 
		operator over Boolean terms, 
		\texttt{Z.eqb} is the Boolean 
		equality predicate symbol over 
		integers in Coq, and 
		\texttt{bv\_ult}
		and \texttt{bv\_eq} are 
		respectively the Boolean 
		less than (over unsigned integers)
		and equality predicate symbols for 
		bit-vectors. \hfill$\Box$
	\end{example}

	\begin{figure}[t]
		\begin{framed}
			\textsc{Step 1}: Coq tactic invokes SMTCoq
			to prove theorem:\\
			\texttt{Theorem F : $P$.}\\
			\texttt{Proof.}\\
  			\texttt{smt.}
		\end{framed}
		\vspace{-0.3in}
		\begin{center}
			$\downarrow$
		\end{center}
		\vspace{-0.3in}
		\begin{framed}
			\textsc{Step 2}: Assuming that $P$
			has predicate symbols $P_1 \ldots P_n$, 
			Coq presents the goal:
			\begin{center}
				$\texttt{Goal}:$ $P(P_1,\  
				\ldots,\ P_n)$
			\end{center}
		\end{framed}
		\vspace{-0.3in}
		\begin{center}
			$\downarrow$
		\end{center}
		\vspace{-0.3in}
		\begin{framed}
			\textsc{Step 3}: The \texttt{smt} tactic
			calls the \texttt{prop2bool} tactic 
			which tries to convert all \texttt{Prop}
			predicates to their Boolean counterparts.
			If \texttt{prop2bool}, fails, so does
			\texttt{smt}. If it succeeds, the goal 
			is now (assuming symbol $P_i$ corresponds
			to Boolean $B_i$):
			\begin{center}
				$\texttt{Goal}: P(B_1,\ \ldots,\ B_n)
				= \texttt{true}$
			\end{center}
			Quantifiers are also faithfully converted ---
			the Boolean variables in the converted 
			goal are bound as the propositional 
			variables were in the original goal.
		\end{framed}
		\vspace{-0.3in}
		\begin{center}
			$\downarrow$
		\end{center}
		\vspace{-0.3in}
		\begin{framed}
			\textsc{Step 4-8}: SMTCoq proves the \texttt{Bool}
			goal using the SMT solver as 
			shown in Fig.~\ref{fig:smtcoqex}.
		\end{framed}
		\caption{SMTCoq's journey in proving 
			example Boolean formula \texttt{F}}
		\label{fig:prop2bool}
	\end{figure}
	
	\begin{figure}
		\begin{framed}
			\textsc{Step 4}: SMTCoq extracts Boolean 
			term \texttt{B} from the goal and creates a deep 
			embedding \texttt{f} of \texttt{B}.
			\begin{center}
				\texttt{B}: $\texttt{B}_1 \ldots \texttt{B}_n$
			\end{center}
		\end{framed}
		\vspace{-0.3in}
		\begin{center}
			$\downarrow$
		\end{center}
		\vspace{-0.3in}
		\begin{framed}
			\textsc{Step 5}: SMT solver 
			proves unsatisfiability of $\neg B$ 
			(the SMT encoding of $\neg$\texttt{B}) 
			and returns proof \texttt{t}.
		\end{framed}
		\vspace{-0.3in}
		\begin{center}
			$\downarrow$
		\end{center}
		\vspace{-0.3in}
		\begin{framed}
			\textsc{Step 4}: Call to SMTCoq's 
			checker checks that \texttt{t}
			proves unsatisfiability of 
			\texttt{$\neg$f}:
			\begin{center}
				$c\ :=\ $\texttt{checker f t = true}
			\end{center}
		\end{framed}
		\vspace{-0.3in}
		\begin{center}
			$\downarrow$
		\end{center}
		\vspace{-0.3in}
		\begin{framed}
			\textsc{Step 5}: Reflection principle 
			reflects deep embedding to shallow 
			embedding $\mathbb{I}(\texttt{f})$
			via call to \texttt{checker} from 
			Step 4:
			\begin{center}
				\texttt{checker\_correct f t 
					(refl\_equal $c$ true)}
			\end{center}
		\end{framed}
		\vspace{-0.3in}
		\begin{center}
			$\downarrow$
		\end{center}
		\vspace{-0.3in}
		\begin{framed}
			\textsc{Step 6}: Proof of \texttt{F} is 
			completed in Coq:
			\begin{minted}{Coq}
Theorem F : P
Proof.
  smt.
Qed.
			\end{minted}
		\end{framed}
		\caption{SMTCoq's journey in proving 
			example Boolean formula \texttt{F}}
		\label{fig:smtcoqex}
	\end{figure}

	SMTCoq is 
	able to prove some
	\texttt{Prop} predicates if they 
	are reducible to their
	corresponding 
	\texttt{Bool} predicates. Such a 
	reduction is specified using 
	lemmas of equivalence between 
	the two. SMTCoq
	defines the \texttt{prop2bool} 
	tactic that converts a 
	\texttt{Prop} predicate symbol
	to its corresponding \texttt{bool}
	counterparts, by applying the 
	equivalence lemma, if one is available. 
	The \texttt{prop2bool}
	tactic only succeeds on a goal if 
	it is able to recursively convert all 
	the predicate symbols in the goal. 
	When a user asks 
	SMTCoq to prove a goal consisting 
	of \texttt{Prop} predicate symbols, the 
	\texttt{smt} tactic first calls the 
	\texttt{prop2bool} tactic to 
	convert all \texttt{Prop} predicate
	symbols	to their corresponding 
	\texttt{bool} predicate symbols. The 
	\texttt{smt} tactic
	then uses the SMT solver to 
	prove the resulting Boolean goal 
	(using the 
	checker and the reflection lemma). 
	If it is successful, the 
	theorem can be closed. This process
	is described by adding the steps in 
	Figure~\ref{fig:prop2bool} to the 
	ones in Figure~\ref{fig:smtcoqex},
	already presented in Report 2.
	
	\begin{example}
		\label{ex:proppred}
		\em Conveniently, the 
		\texttt{prop2bool} tactic 
		is successful with the predicate 
		symbols used in Example~\ref{ex:boolpred}.
		So, SMTCoq can prove their 
		corresponding \texttt{Prop}
		theorems:
		\begin{minted}{Coq}
Theorem Z_congProp : forall (a b : Z) (f : Z -> Z), a = b -> 
  f a = f b.
Proof.
  smt.
Qed.
	
Theorem BV_ulteZeroProp : forall (b : bitvector 4), 
  bv_ultP #b|0|0|0|0| b \/ b = #b|0|0|0|0|.
Proof.
  smt.
Qed.
		\end{minted}
		\hfill$\Box$
	\end{example}
	
	Depending on the predicate symbol,
	some of the equivalence lemmas 
	between the \texttt{Prop} and 
	\texttt{bool} versions are 
	either in Coq's libraries, or
	proved in SMTCoq's libraries.
	
	\begin{example}
		\em SMTCoq's bitvector library 
		proves the following lemma of 
		equivalence between the 
		\texttt{Bool} and \texttt{Prop} 
		version of the unsigned less than 
		predicate over bit-vectors.
		This equivalence lemma is used
		by SMTCoq's \texttt{prop2bool} 
		tactic when 
		a user uses the \texttt{Prop}
		version of this predicate symbol in 
		a query to SMTCoq, as in 
		\texttt{BV\_ulteZeroProp} from
		Example~\ref{ex:proppred}.
\begin{minted}{Coq}
Theorem bv_ult_B2P : forall n (a b : bitvector n), 
  bv_ult a b = true <-> bv_ultP a b.
\end{minted}
		
		An example of an equivalence 
		proved in a Coq library is
		that of the integer less than 
		predicate.
\begin{minted}{Coq}
Lemma ltb_lt (n m : Z) : (n <? m) = true <-> n < m.
\end{minted}
	\hfill $\Box$
	\end{example}
	
\bibliographystyle{abbrv}
\bibliography{bib3}

\end{document}